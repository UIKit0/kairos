Recently I needed to port some unix software to Windows CE and I needed to implement the _creat and _open function declared normally in <fcntl.h>.
These functions binds an integer value called a file descriptor to a file.
On Windows and Windows mobile, every file is created/modified by the CreateFile function that returns an OS file handle (HANDLE).
So to be able to port the posix functions I needed to maintain a table  between a file descriptor and a native OS handle.

Actually instead of using CreateFile, I have decided to use fopen because it's simpler and more appropriate and I wanted to get the underlying OS file handle (HANDLE) from a FILE*.

On Windows CE (5.0 - 5.2) fopen/fclose are implemented as shown below :


{geshibot lang="c++" head="fopen implementation on Windows CE" foot="C:\WINCE600\PRIVATE\WINCEOS\COREOS\CORE\CORELIBC\CRTW32\STDIO\fopen.c"}
typedef struct
{
    char *_ptr;
    int   _cnt;
    char *_base;
    int   _flag;
    int   _charbuf;
    int   _bufsiz;
    CRITICAL_SECTION lock;
    // moved here from the ioinfo struct
    HANDLE osfhnd;  /* underlying OS file HANDLE */
    char   osfile;  /* attributes of file (e.g., open in text mode?) */
    char   peekch;  /* one byte lookahead reqd for CRLF translations */
    int    fd;      // used to figure out if this is one of the special stdin/out/err
}
_FILEX;
typedef _FILEX FILEX;

FILE* __cdecl _wfopen(const WCHAR *filename, const WCHAR *mode)
{
    FILE* pfret = NULL;
    _wfopen_int(&pfret, filename, mode, INVALID_HANDLE_VALUE, NULL, _SH_DENYNO);
    return pfret;
}




static errno_t _wfopen_int (
    FILE** ppfile,
    const WCHAR *filename,
    const WCHAR *mode,
    HANDLE hFile,     //INVALID_HANDLE_VALUE
    FILEX* stream,    //NULL
    int shflag
    )
{
...
*ppfile = (FILE*)stream;
}{/geshibot}

As you can see a FILE*is actually a pointer to a FILEX struct. So we can see that to get file OS handle from a FILE* we just need to cast it to FILEX*and deference the pointer to get the osfhnd field.

And since we are very lucky we can also see that we are able to retrieve the associated file descriptor ! 

{geshibot lang="c++"}
int _tmain(int argc, _TCHAR* argv[])
{
    FILEX* _pfilex;

    printf( "The file handle for stdin  is (FILE*=0x%x, fd=%d, HANDLE=0x%x)\n", 
        stdin, ((FILEX*)(stdin))->fd,  ((FILEX*)(stdin))->osfhnd);
    printf( "The file handle for stdout is (FILE*=0x%x, fd=%d, HANDLE=0x%x)\n", 
        stdout, ((FILEX*)(stdout))->fd,  ((FILEX*)(stdout))->osfhnd);
    printf( "The file handle for stderr is (FILE*=0x%x, fd=%d, HANDLE=0x%x)\n", 
        stderr, ((FILEX*)(stderr))->fd,  ((FILEX*)(stderr))->osfhnd);
    
    FILE*  stream1 = fopen("\\Test.txt", "a+");
    if (stream1)
    {
        fwrite(
            _T("I want to know Windows CE internals"), 
            sizeof(TCHAR),
            _tcslen(_T("I want to know Windows CE internals")),
            stream1
            );
        fflush(stream1);
        
        _pfilex = (FILEX*)stream1;

        printf( "The file handle for stream1 is (FILE*=0x%x, fd=%d, HANDLE=0x%x)\n", 
            stream1, ((FILEX*)(stream1))->fd,  ((FILEX*)(stream1))->osfhnd );

        fclose(stream1);
    }
    return 0;
}{/geshibot}

In the debugger here is the result :

The file handle for stdin  is (FILE*=0x300d0, fd=0, HANDLE=0xffffffff)
The file handle for stdout is (FILE*=0x30110, fd=1, HANDLE=0xfffffffe)
The file handle for stderr is (FILE*=0x30150, fd=2, HANDLE=0xffffffff)
The file handle for stream1 is (FILE*=0x311d0, fd=3, HANDLE=0x3763d0aa)

 For information, here is the maximum number of files that can be opened using fopen on difefrent platforms:

Pocket PC 2003 : infinite
Windows Mobile 5 & 6: 1098